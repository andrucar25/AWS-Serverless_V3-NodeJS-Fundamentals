import { A, B } from "ts-toolbelt";
import { Get, And, DoesExtend } from "json-schema-to-ts/lib/utils";
import { MetaType, Never, Const, Error } from "json-schema-to-ts/lib/meta-types";
import { Arr, Values } from "json-schema-to-ts/lib/meta-types/array";
import { Values as TupleValues, IsOpen, OpenProps } from "json-schema-to-ts/lib/meta-types/tuple";
import { Exclude } from "json-schema-to-ts/lib/meta-types/exclusion";
import { ExcludeUnion } from "json-schema-to-ts/lib/meta-types/exclusion/union";
import { ExcludeIntersection } from "json-schema-to-ts/lib/meta-types/exclusion/intersection";
import { ExcludeExclusion } from "json-schema-to-ts/lib/meta-types/exclusion/exclusion";
import { IsRepresentable } from "json-schema-to-ts/lib/meta-types/utils";
export declare type ExcludeFromArray<Source, Excluded> = {
    any: Never;
    never: Source;
    const: Source;
    enum: Source;
    primitive: Source;
    array: ExcludeArrs<Source, Excluded>;
    tuple: And<DoesExtend<A.Equals<TupleValues<Excluded>, []>, B.True>, IsOpen<Excluded>> extends true ? ExcludeArrs<Source, Arr<OpenProps<Excluded>>> : Source;
    object: Source;
    union: ExcludeUnion<Source, Excluded>;
    intersection: ExcludeIntersection<Source, Excluded>;
    exclusion: ExcludeExclusion<Source, Excluded>;
    error: Excluded;
    errorTypeProperty: Error<"Missing type property">;
}[Get<Excluded, "type"> extends MetaType ? Get<Excluded, "type"> : "errorTypeProperty"];
declare type ExcludeArrs<Source, Excluded, ExcludedValues = Exclude<Values<Source>, Values<Excluded>>> = IsRepresentable<ExcludedValues> extends true ? Source : Const<[]>;
export {};
